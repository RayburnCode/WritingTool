use uuid::Uuid;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use sqlx::FromRow;
use validator::Validate;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow, Validate)]
pub struct MaintenanceWindow {
    pub id: Uuid,
    #[validate(range(min = "now", message = "Must be in the future"))]
    pub starts_at: DateTime<Utc>,
    #[validate(range(min = "starts_at", message = "Must be after start time"))]
    pub ends_at: DateTime<Utc>,
    #[validate(length(min = 10, max = 1000))]
    pub description: String,
    #[serde(skip)] // Generated by DB
    pub is_active: bool,
    pub created_by: Option<Uuid>,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub created_at: DateTime<Utc>,
}

impl MaintenanceWindow {
    /// Creates a new maintenance window builder
    pub fn builder() -> MaintenanceWindowBuilder {
        MaintenanceWindowBuilder::default()
    }

    /// Checks if currently active (local calculation)
    pub fn is_active_now(&self) -> bool {
        let now = Utc::now();
        now >= self.starts_at && now <= self.ends_at
    }

    /// Checks if the window overlaps with another
    pub fn overlaps(&self, other: &Self) -> bool {
        self.starts_at <= other.ends_at && other.starts_at <= self.ends_at
    }

    /// Duration of the maintenance window
    pub fn duration(&self) -> chrono::Duration {
        self.ends_at - self.starts_at
    }

    /// Time remaining until maintenance starts
    pub fn starts_in(&self) -> chrono::Duration {
        self.starts_at - Utc::now()
    }
}

/// Builder pattern for maintenance windows
#[derive(Debug, Default)]
pub struct MaintenanceWindowBuilder {
    starts_at: Option<DateTime<Utc>>,
    ends_at: Option<DateTime<Utc>>,
    description: Option<String>,
    created_by: Option<Uuid>,
}

impl MaintenanceWindowBuilder {
    pub fn starts_at(mut self, time: DateTime<Utc>) -> Self {
        self.starts_at = Some(time);
        self
    }

    pub fn ends_at(mut self, time: DateTime<Utc>) -> Self {
        self.ends_at = Some(time);
        self
    }

    pub fn duration_minutes(mut self, minutes: i64) -> Self {
        if let Some(starts_at) = self.starts_at {
            self.ends_at = Some(starts_at + chrono::Duration::minutes(minutes));
        }
        self
    }

    pub fn description(mut self, desc: impl Into<String>) -> Self {
        self.description = Some(desc.into());
        self
    }

    pub fn created_by(mut self, user_id: Uuid) -> Self {
        self.created_by = Some(user_id);
        self
    }

    pub fn build(self) -> Result<MaintenanceWindow, validator::ValidationErrors> {
        let window = MaintenanceWindow {
            id: Uuid::new_v4(),
            starts_at: self.starts_at.unwrap_or_else(|| Utc::now() + chrono::Duration::hours(1)),
            ends_at: self.ends_at.unwrap_or_else(|| Utc::now() + chrono::Duration::hours(2)),
            description: self.description.unwrap_or_else(|| "Scheduled maintenance".to_string()),
            is_active: false, // Will be set by database
            created_by: self.created_by,
            created_at: Utc::now(),
        };

        window.validate()?;
        Ok(window)
    }
}

/// Session extension for maintenance mode
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Session {
    // ... your existing session fields ...
    pub is_maintenance: bool,
}

/// System maintenance status
#[derive(Debug, Serialize)]
pub struct SystemStatus {
    pub is_maintenance: bool,
    pub current_window: Option<MaintenanceWindow>,
    pub next_window: Option<MaintenanceWindow>,
}

/// Maintenance service
pub struct MaintenanceService {
    pool: sqlx::PgPool,
}

impl MaintenanceService {
    pub fn new(pool: sqlx::PgPool) -> Self {
        Self { pool }
    }

    /// Get current system maintenance status
    pub async fn get_status(&self) -> Result<SystemStatus, sqlx::Error> {
        let current = sqlx::query_as!(
            MaintenanceWindow,
            r#"SELECT * FROM maintenance_windows WHERE NOW() BETWEEN starts_at AND ends_at"#
        )
        .fetch_optional(&self.pool)
        .await?;

        let next = sqlx::query_as!(
            MaintenanceWindow,
            r#"SELECT * FROM maintenance_windows WHERE starts_at > NOW() ORDER BY starts_at LIMIT 1"#
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(SystemStatus {
            is_maintenance: current.is_some(),
            current_window: current,
            next_window: next,
        })
    }

    /// Check if maintenance mode is active
    pub async fn is_active(&self) -> Result<bool, sqlx::Error> {
        Ok(
            sqlx::query_scalar!(
                r#"SELECT EXISTS(SELECT 1 FROM maintenance_windows WHERE NOW() BETWEEN starts_at AND ends_at)"#
            )
            .fetch_one(&self.pool)
            .await?
        )
    }

    /// Mark sessions created during maintenance
    pub async fn mark_maintenance_sessions(&self) -> Result<u64, sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE sessions 
            SET is_maintenance = true
            WHERE created_at BETWEEN 
                (SELECT starts_at FROM maintenance_windows WHERE NOW() BETWEEN starts_at AND ends_at)
                AND NOW()
            "#
        )
        .execute(&self.pool)
        .await
        .map(|r| r.rows_affected())
    }
}

/// API response DTO
#[derive(Debug, Serialize)]
pub struct MaintenanceWindowResponse {
    pub id: Uuid,
    pub starts_at: DateTime<Utc>,
    pub ends_at: DateTime<Utc>,
    pub description: String,
    pub is_active: bool,
    pub duration_minutes: i64,
    pub starts_in_minutes: i64,
}

impl From<MaintenanceWindow> for MaintenanceWindowResponse {
    fn from(window: MaintenanceWindow) -> Self {
        Self {
            id: window.id,
            starts_at: window.starts_at,
            ends_at: window.ends_at,
            description: window.description,
            is_active: window.is_active_now(),
            duration_minutes: window.duration().num_minutes(),
            starts_in_minutes: window.starts_in().num_minutes(),
        }
    }
}